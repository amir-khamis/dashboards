<form hideEdit="false" script="common_control.js, table_cell_highlighting.js, table_cell_highlighting1.js" stylesheet="shared.css, health-check.css, table_cell_highlighting.css" theme="light">
  <label></label>
  <search id="members_heartbeat_timeout_base" base="membersSnapshotSearch">
    <query>
          fields label, status, last_heartbeat, last_heartbeat_captain
          | join label type=outer [
            | rest splunk_server_group="$group$" splunk_server_group=dmc_group_search_head /services/configs/conf-server/shclustering
            | fields splunk_server, heartbeat_timeout
            | rename splunk_server as label
          ]
          | where status != "Up" OR (last_heartbeat_captain - last_heartbeat) &gt; heartbeat_timeout
        </query>
    <preview>
      <condition match="$job.resultCount$ &gt; 0">
        <set token="member_heartbeat_text_unhealthy">There are members in this cluster that do not have a healthy heartbeat status.</set>
      </condition>
      <condition match="$job.resultCount$ = 0">
        <set token="member_heartbeat_text_healthy">All members in this cluster have a healthy heartbeat status.</set>
      </condition>
    </preview>
  </search>
  <search id="member_peer_consistency_base">
    <query>
          | rest splunk_server_group="$group$" splunk_server_group=dmc_group_search_head /services/search/distributed/peers
          | fields splunk_server, peerName
          | stats values(peerName) as peers by splunk_server
          | nomv peers
          | stats values(splunk_server) AS search_heads by peers
          | makemv peers
          | fields search_heads peers
          | rename search_heads as "Search Head Cluster Member", peers as "Search Peer List"
        </query>
    <preview>
      <condition match="$job.resultCount$ &gt; 1">
        <set token="member_peer_inconsistency_text">The list of distributed search peers is inconsistent among cluster members. This could result in inconsistent search results within the search head cluster.</set>
      </condition>
    </preview>
  </search>
  <search base="membersSnapshotSearch">
    <query>
          where total_no_shared_common_baseline+total_unable_to_connect &gt; 0
        </query>
    <preview>
      <condition match="$job.resultCount$ &gt; 0">
        <set token="common_baseline_text_unhealthy">There are members in this cluster that do not share a common baseline. Action may be required.</set>
        <unset token="common_baseline_text_healthy"></unset>
      </condition>
      <condition match="$job.resultCount$ = 0">
        <set token="common_baseline_text_healthy">All members in this cluster share a common baseline.</set>
        <unset token="common_baseline_text_unhealthy"></unset>
      </condition>
    </preview>
  </search>
  <search id="snapshot_search_concurrency_base">
    <query>
          | rest splunk_server_group="$group$" splunk_server_group=dmc_group_search_head /services/server/status/resource-usage/splunk-processes
          | search search_props.role="head"
          | dedup search_props.sid
        </query>
  </search>
  <search id="search_concurrency_vs_limits_base" base="snapshot_search_concurrency_base">
    <query>
            stats count(eval(('search_props.type'=="scheduled" OR 'search_props.type'=="summary indexing" OR 'search_props.type'=="report acceleration" OR 'search_props.type'=="datamodel acceleration" OR 'search_props.type'=="ad-hoc") AND ('search_props.mode'=="historical" OR 'search_props.mode'=="historical batch"))) as count_total_hist,
            count(eval(('search_props.type'=="scheduled" OR 'search_props.type'=="summary indexing" OR 'search_props.type'=="report acceleration" OR 'search_props.type'=="datamodel acceleration" OR 'search_props.type'=="ad-hoc") AND ('search_props.mode'=="RT" OR 'search_props.mode'=="RT indexed"))) as count_total_rt,
            count(eval(('search_props.type'=="scheduled" OR 'search_props.type'=="summary indexing" OR 'search_props.type'=="report acceleration" OR 'search_props.type'=="datamodel acceleration") AND ('search_props.mode'=="historical" OR 'search_props.mode'=="historical batch"))) as count_hist_scheduled_search,
            count(eval(('search_props.type'=="scheduled" OR 'search_props.type'=="summary indexing" OR 'search_props.type'=="report acceleration" OR 'search_props.type'=="datamodel acceleration") AND ('search_props.mode'=="RT" OR 'search_props.mode'=="RT indexed"))) as count_rt_scheduled_search,
            count(eval(('search_props.type'=="report acceleration" OR 'search_props.type'=="datamodel acceleration"))) as count_auto_summary_search
            | eval count_total_adhoc_scheduled_search = count_total_hist + count_total_rt
            | eval count_total_scheduled_search = count_hist_scheduled_search + count_rt_scheduled_search
            | eval dummy_key = "dummy_key"
            | fields count_total_hist, count_hist_scheduled_search,
                     count_total_rt, count_rt_scheduled_search,
                     count_auto_summary_search,
                     count_total_adhoc_scheduled_search, count_total_scheduled_search,
                     dummy_key
            | join dummy_key type=outer [
              | rest splunk_server_group="$group$" splunk_server_group=dmc_group_search_head "/services/server/status/limits/search-concurrency?cluster_wide_quota=1"
              | stats max(max_hist_searches) as max_hist_searches, max(max_hist_scheduled_searches) as max_hist_scheduled_searches, max(max_rt_searches), as max_rt_searches, max(max_rt_scheduled_searches) as max_rt_scheduled_searches, max(max_auto_summary_searches) as max_auto_summary_searches
              | eval dummy_key = "dummy_key"
              | fields max_hist_searches, max_hist_scheduled_searches,
                  max_rt_searches, max_rt_scheduled_searches,
                  max_auto_summary_searches,
                  dummy_key
            ]
          </query>
    <preview>
      <eval token="count_total_adhoc_scheduled_search">if(isnotnull('result.count_total_adhoc_scheduled_search'), 'result.count_total_adhoc_scheduled_search', 0)</eval>
      <eval token="count_total_scheduled_search">if(isnotnull('result.count_total_scheduled_search'), 'result.count_total_scheduled_search', 0)</eval>
    </preview>
  </search>
  <search id="shcSearchConBase">
    <query>
        `dmc_set_index_introspection` search_group=dmc_group_search_head search_group="$group$" sourcetype=splunk_resource_usage ((component=PerProcess data.search_props.sid::*) OR component=Hostwide)
        | `dmc_rename_introspection_fields`
        | `dmc_set_bin`
        | stats dc(sid) AS distinct_search_count by provenance, mode, app, type, user, host, _time
        </query>
    <earliest>$time.earliest$</earliest>
    <latest>$time.latest$</latest>
  </search>
  <search id="captainElectionBaseSearch">
    <query>
`dmc_set_index_internal` search_group="$group$" sourcetype=splunkd component=Metrics group=captainstability upgrades_to_captain=1
| stats count by _time, upgrades_to_captain, host
        </query>
    <earliest>$time.earliest$</earliest>
    <latest>$time.latest$</latest>
  </search>
  <search id="captainSnapshotSearch">
    <query>
      | rest splunk_server_group=$group$ splunk_server_group=dmc_group_search_head /services/shcluster/captain/info
      | dedup peer_scheme_host_port
      | fields label
    </query>
    <finalized>
      <set token="captain_name">$result.label$</set>
    </finalized>
  </search>
  <search id="membersSnapshotSearch">
    <query>
| rest splunk_server=local /services/search/distributed/peers
| where search_groups="$group$" AND server_roles="search_head"
| eval label = host
| join guid type=outer [
  | rest splunk_server_group="$group$" splunk_server_group=dmc_group_search_head /services/shcluster/member/members count=0
  | dedup label
  | eval guid = title
]
| join label type=outer [
  | rest splunk_server=$captain_name$ /services/shcluster/captain/members count=0
  | where splunk_server == label
  | fields label, last_heartbeat
  | rename last_heartbeat as last_heartbeat_captain
]
| eventstats values(last_heartbeat_captain) as last_heartbeat_captain
| join label type=outer [
  | rest splunk_server_group="$group$" splunk_server_group=dmc_group_search_head /services/shcluster/captain/info
  | where splunk_server == label
  | eval age = now() - elected_captain
  | eval captain_age = case(age &lt; 60, "&lt; 1m", age &gt;= 60 AND age &lt; 3600, round(age / 60, 0)."m", age &gt;= 3600 AND age &lt; 86400, round(age / 3600, 0)."h", age &gt;= 86400, round(age / 86400, 0)."d")
  | `dmc_time_format(elected_captain)`
  | eval role = "Captain (" . captain_age . ")"
  | fields label captain_age elected_captain role
]
| join label type=outer [
  | rest /services/replication/configuration/health check_share_baseline=1 splunk_server_group="$group$" splunk_server_group=dmc_group_search_head
  | stats values(server_name) as baselines, count(server_name) as num_baselines by splunk_server, check_share_baseline
  | eval shared_common_baseline = if(check_share_baseline == "Yes", baselines, "")
  | eval no_shared_common_baseline = if(check_share_baseline == "No", baselines, "")
  | eval unable_to_connect = if(check_share_baseline == "Connection error", baselines, "")
  | eval num_shared_common_baseline = if(check_share_baseline == "Yes", num_baselines, 0)
  | eval num_no_shared_common_baseline = if(check_share_baseline == "No", num_baselines, 0)
  | eval num_unable_to_connect = if(check_share_baseline == "Connection error", num_baselines, 0)
  | stats sum(num_shared_common_baseline) as total_shared_common_baseline, sum(num_no_shared_common_baseline) as total_no_shared_common_baseline, sum(num_unable_to_connect) as total_unable_to_connect, values(shared_common_baseline) as shared_common_baseline, values(no_shared_common_baseline) as no_shared_common_baseline, values(unable_to_connect) as unable_to_connect by splunk_server
  | eval ratio = total_shared_common_baseline . "/" . (total_shared_common_baseline+total_no_shared_common_baseline+total_unable_to_connect)
  | rename splunk_server as label
]
| join label type=outer [
  | rest /services/replication/configuration/health unpublished=1 splunk_server_group="$group$" splunk_server_group=dmc_group_search_head
  | rename "Number of unpublished changes" as unpublished_changes
  | eval unpublished_changes=if(unpublished_changes=="0 (this instance is the captain)", 0, unpublished_changes)
  | rename splunk_server as label
]
| eval role = if(isnotnull(role), role, "Member")
| sort role
    </query>
  </search>
  <fieldset autoRun="true" submitButton="false">
    <input type="dropdown" searchWhenChanged="true" token="group">
      <label>Search Head Cluster:</label>
      <showClearButton>false</showClearButton>
      <populatingSearch fieldForLabel="label" fieldForValue="search_group">| `dmc_get_search_head_cluster_groups`</populatingSearch>
      <selectFirstChoice>true</selectFirstChoice>
      <fieldForLabel>label</fieldForLabel>
      <fieldForValue>search_group</fieldForValue>
    </input>
    <input type="time" token="time" searchWhenChanged="true">
      <label></label>
      <default>
        <earliest>-60m@m</earliest>
        <latest>now</latest>
      </default>
    </input>
  </fieldset>
  <row>
    <panel>
      <table>
        <search>
          <query>| rest splunk_server_group=dmc_group_search_head splunk_server_group="$group$" /servicesNS/-/-/saved/searches search="is_scheduled=1" search="disabled=0"
            | stats count by splunk_server
            | join splunk_server type=outer [
              | rest splunk_server_group=dmc_group_search_head splunk_server_group="$group$" /services/server/status/limits/search-concurrency
              | fields splunk_server max_hist_scheduled_searches, max_rt_scheduled_searches]
            | join splunk_server type=outer [
              | rest splunk_server_group=dmc_group_search_head splunk_server_group="$group$" /services/server/status/resource-usage/splunk-processes
              | search search_props.role="head" `dmc_match_all_scheduled_search_types`
              | dedup search_props.sid
              | stats count(eval('search_props.mode'=="historical batch" OR 'search_props.mode'=="historical")) as count_hist_search, count(eval('search_props.mode'=="RT" OR 'search_props.mode'=="RT indexed")) as count_rt_search by splunk_server ]
            | join splunk_server type=outer [
              | rest splunk_server_group=dmc_group_search_head splunk_server_group="$group$" /services/server/info
              | fields splunk_server,version,physicalMemoryMB, numberOfCores, numberOfVirtualCores]
            | eval count_hist_search = if(isnull(count_hist_search), 0, count_hist_search)
            | eval count_rt_search = if(isnull(count_rt_search), 0, count_rt_search)
            | eval hist_concur_vs_limit = count_hist_search." / ".max_hist_scheduled_searches
            | eval rt_concur_vs_limit = count_rt_search." / ".max_rt_scheduled_searches
            | `dmc_get_core_info`
            | fields splunk_server,version, core_info,physicalMemoryMB 
            | rename splunk_server as Instance, core_info AS "CPU Cores (Physical / Virtual)"</query>
          <earliest>$time.earliest$</earliest>
          <latest>$time.latest$</latest>
          <sampleRatio>1</sampleRatio>
        </search>
        <option name="count">20</option>
        <option name="dataOverlayMode">none</option>
        <option name="drilldown">cell</option>
        <option name="percentagesRow">false</option>
        <option name="refresh.display">progressbar</option>
        <option name="rowNumbers">false</option>
        <option name="totalsRow">false</option>
        <option name="wrap">true</option>
        <drilldown>
          <link target="_blank">search?q=| rest /servicesNS/-/-/saved/searches splunk_server=$captain_name$ | where is_scheduled=1 | search disabled=0  | stats count by  title next_scheduled_time cron_schedule schedule_priority schedule_window dispatch.earliest_time dispatch.latest_time| fields title next_scheduled_time cron_schedule schedule_priority schedule_window dispatch.earliest_time dispatch.latest_time| rename title as savedsearch_name | join savedsearch_name [search index=_internal search_group=dmc_group_search_head search_group=$group$ sourcetype=scheduler  status=*  dispatch_time=*]&amp;earliest=$time.earliest$&amp;latest=$time.latest$</link>
        </drilldown>
      </table>
    </panel>
  </row>
  <row>
    <panel>
      <html>
        <h1>
          <b>
            <span style="color: #ED179F">Search Concurrency Limits</span>  </b>
        
        </h1>
      </html>
      <table>
        <search>
          <query>| rest  splunk_server=$captain_name$ "/services/server/status/limits/search-concurrency?cluster_wide_quota=1" | table max* | transpose | rename column as "search_type" | rename "row 1" as "concurrency limit"  | table search_type  "concurrency limit" | sort -"concurrency limit"</query>
          <earliest>-60m@m</earliest>
          <latest>now</latest>
          <sampleRatio>1</sampleRatio>
        </search>
        <option name="count">5</option>
        <option name="dataOverlayMode">none</option>
        <option name="drilldown">none</option>
        <option name="percentagesRow">false</option>
        <option name="refresh.display">progressbar</option>
        <option name="rowNumbers">false</option>
        <option name="totalsRow">false</option>
        <option name="wrap">true</option>
      </table>
    </panel>
  </row>
  <row>
    <panel>
      <html>
        <h1>
          <b>
            <span style="color: #ED179F">All-Time searches</span>  </b>
        
        </h1>
        <b>Description:</b> Identifies searches with no earliest time set, hence running over all time which is expensive</html>
      <html>
        <b>Recommended Action:</b>Set a dispatch.earliest_time for these searches</html>
      <table>
        <search>
          <query>| rest /servicesNS/-/-/saved/searches splunk_server=$captain_name$ | where is_scheduled=1 | search disabled=0   | search title!="Bucket Copy Trigger" dispatch.earliest_time="" OR dispatch.earliest_time=0  | rename eai:acl.* as *  | table title app owner cron_schedule dispatch.earliest_time dispatch.latest_time  search | search search!=*earliest* | search search=*index* | rename title as "savedsearch name"</query>
          <earliest>$time.earliest$</earliest>
          <latest>$time.latest$</latest>
          <sampleRatio>1</sampleRatio>
        </search>
        <option name="count">5</option>
        <option name="dataOverlayMode">none</option>
        <option name="drilldown">none</option>
        <option name="percentagesRow">false</option>
        <option name="refresh.display">progressbar</option>
        <option name="rowNumbers">true</option>
        <option name="totalsRow">false</option>
        <option name="wrap">true</option>
      </table>
    </panel>
  </row>
  <row>
    <panel>
      <html>
         <h1>
          <b>
            <span style="color: #ED179F">Real-Time searches</span>  </b>
        
        </h1>
        <b>Description:</b> Identifies real-time searches which may be running. Real-time searches will have a significant impact on performance in high volume environments and network load when you have many concurrent real-time searches.</html>
      <html>
        <b>Recommended Action:</b> <p>
          <b>a.)</b> Eliminate non-essential RT searches</p>
      <p>
          <b>b.)</b> Use indexed realtime by default = true on all SHs for any rt searches that must run</p>
<p>SHs limits.conf</p>
<p>[realtime]</p>
<p>indexed_realtime_use_by_default = true</p>
<p>
          <b>c.)</b> Consider removing rt search capability of non power/admin users from their role:</p>
<p>SHs authorize.conf:</p>
<p>[role_&lt;rolename&gt;]</p>
<p>rtSrchJobsQuota = 0</p>
<p>cumulativeRTSrchJobsQuota = 0</p>
<p>schedule_rtsearch = disabled</p>
  <p>
          <b>d.)</b> Disable ad-hoc rt_md searches which will run when a user is sitting on the search page of the search app as count of events under "What to Search" is being updated</p>    
SHs $SPLUNK_HOME/etc/system/local/ui-prefs.conf 
<p>[search]</p>
<p>display.prefs.enableMetaData=0</p> 
      </html>
      <table>
        <search>
          <query>index=_introspection search_group=dmc_group_search_head search_group=$group$ sourcetype=splunk_resource_usage (component=PerProcess data.search_props.sid::*)    "data.search_props.mode"=*RT* | dedup "data.search_props.label" | table data.search_props.label data.search_props.app data.search_props.mode data.search_props.sid data.elapsed | rename data.search_props.label as "savedsearch name" data.search_props.app as app data.search_props.mode as mode data.search_props.sid as sid data.elapsed as "has been running for (seconds)"</query>
          <earliest>-60m@m</earliest>
          <latest>now</latest>
          <sampleRatio>1</sampleRatio>
        </search>
        <option name="count">5</option>
        <option name="dataOverlayMode">none</option>
        <option name="drilldown">none</option>
        <option name="percentagesRow">false</option>
        <option name="rowNumbers">true</option>
        <option name="totalsRow">false</option>
        <option name="wrap">true</option>
      </table>
    </panel>
  </row>
  <row>
    <panel>
      <html>
         <h1>
          <b>
            <span style="color: #ED179F">Frequency and Duration Comparison</span>  </b>
        
        </h1>
    
        <b>Description:</b> Identifies inefficient searches by comparing earliest time and cron schedule frequency</html>
      <html>
        <b>Recommended Action:</b> Adjust dispatch.earliest_time for searches with a high ratio 
        <p>For example a search running every 5m should in most cases have a dispatch.earliest_time of -5m</p>
      </html>
      <table>
        <search>
          <query>index=_audit sourcetype=audittrail source=audittrail savedsearch_name!="" TERM(action=search) ( TERM(info=completed) OR ( TERM(info=granted) search_et=* "search='search")) NOT "search_id='rsa_*" 
| eval timesearched = round((search_lt-search_et),0)
| fields savedsearch_name, timesearched, user
| join savedsearch_name 
    [| rest splunk_server=$captain_name$ "/servicesNS/-/-/saved/searches/" search="is_scheduled=1" search="disabled=0" 
    | fields title, cron_schedule, eai:acl.app
    | rename title as savedsearch_name 
    | eval pieces=split(cron_schedule, " ") 
    | eval c_min=mvindex(pieces, 0), c_h=mvindex(pieces, 1), c_d=mvindex(pieces, 2), c_mday=mvindex(pieces, 3), c_wday=mvindex(pieces, 4) 
    | eval c_min_div=if(match(c_min, "/"), replace(c_min, "^.*/(\d+)$", "\1"), null()) 
    | eval c_mins=if(match(c_min, ","), split(c_min, ","), null()) 
    | eval c_min_div=if(isnotnull(c_mins), abs(tonumber(mvindex(c_mins, 1)) - tonumber(mvindex(c_mins, 0))), c_min_div) 
    | eval c_hs=if(match(c_h, ","), split(c_h, ","), null()) 
    | eval c_h_div=case(match(c_h, "/"), replace(c_h, "^.*/(\d+)$", "\1"), isnotnull(c_hs), abs(tonumber(mvindex(c_hs, 1)) - tonumber(mvindex(c_hs, 0))), 1=1, null()) 
    | eval c_wdays=if(match(c_wday, ","), split(c_wday, ","), null()) 
    | eval c_wday_div=case(match(c_wday, "/"), replace(c_wday, "^.*/(\d+)$", "\1"), isnotnull(c_wdays), abs(tonumber(mvindex(c_wdays, 1)) - tonumber(mvindex(c_wdays, 0))), 1=1, null()) 
    | eval i_m=case(c_d &lt; 29, 86400 * 28, c_d = 31, 86400 * 31, 1=1, null()) 
    | eval i_h=case(isnotnull(c_h_div), c_h_div * 3600, c_h = "*", null(), match(c_h, "^\d+$"), 86400) 
    | eval i_min=case(isnotnull(c_min_div), c_min_div * 60, c_min = "*", 60, match(c_min, "^\d+$"), 3600) 
    | eval i_wk=case(isnotnull(c_wday_div), c_wday_div * 86400, c_wday = "*", null(), match(c_wday, "^\d+$"), 604800) 
    | eval cron_minimum_freq=case(isnotnull(i_m), i_m, isnotnull(i_wk) AND isnotnull(c_min_div), i_min, isnotnull(i_wk) AND isnull(c_min_div), i_wk, isnotnull(i_h), i_h, 1=1, min(i_min)) 
    | fields - c_d c_h c_hs c_h_div c_mday c_min c_min_div c_mins c_wday c_wdays c_wday_div pieces i_m i_min i_h i_wk 
    | fields savedsearch_name cron_minimum_freq cron_schedule eai:acl.app] 
| eval magic=cron_minimum_freq*3 
| where timesearched&gt;magic
| eval ratio=round(timesearched/cron_minimum_freq,0) . ":" . 1, timesearched=round(timesearched/60,0), cron_minimum_freq=cron_minimum_freq/60
| dedup savedsearch_name 
| table savedsearch_name, eai:acl.app, user, timesearched, cron_minimum_freq, cron_schedule, ratio 
| rename savedsearch_name AS "Saved Search Name", eai:acl.app AS "App", user AS "User", timesearched AS "Time Searched (Minutes)", cron_minimum_freq as "Minimum Frequency (Minutes)", cron_schedule AS "Cron Schedule", ratio as Ratio | sort -Ratio</query>
          <earliest>$time.earliest$</earliest>
          <latest>$time.latest$</latest>
          <sampleRatio>1</sampleRatio>
        </search>
        <option name="count">5</option>
        <option name="dataOverlayMode">none</option>
        <option name="drilldown">none</option>
        <option name="percentagesRow">false</option>
        <option name="refresh.display">progressbar</option>
        <option name="rowNumbers">true</option>
        <option name="totalsRow">false</option>
        <option name="wrap">true</option>
      </table>
    </panel>
  </row>
  <row>
    <panel>
      <table>
        <search>
          <query>index=_audit sourcetype=audittrail source=audittrail savedsearch_name!="" TERM(action=search) ( TERM(info=completed) OR ( TERM(info=granted) search_et=* "search='search")) NOT "search_id='rsa_*" 
| eval timesearched = round((search_lt-search_et),0)
| fields savedsearch_name, timesearched, user
| join savedsearch_name 
    [| rest splunk_server=$captain_name$ "/servicesNS/-/-/saved/searches/" search="is_scheduled=1" search="disabled=0" 
    | fields title, cron_schedule, eai:acl.app
    | rename title as savedsearch_name 
    | eval pieces=split(cron_schedule, " ") 
    | eval c_min=mvindex(pieces, 0), c_h=mvindex(pieces, 1), c_d=mvindex(pieces, 2), c_mday=mvindex(pieces, 3), c_wday=mvindex(pieces, 4) 
    | eval c_min_div=if(match(c_min, "/"), replace(c_min, "^.*/(\d+)$$", "\1"), null()) 
    | eval c_mins=if(match(c_min, ","), split(c_min, ","), null()) 
    | eval c_min_div=if(isnotnull(c_mins), abs(tonumber(mvindex(c_mins, 1)) - tonumber(mvindex(c_mins, 0))), c_min_div) 
    | eval c_hs=if(match(c_h, ","), split(c_h, ","), null()) 
    | eval c_h_div=case(match(c_h, "/"), replace(c_h, "^.*/(\d+)$$", "\1"), isnotnull(c_hs), abs(tonumber(mvindex(c_hs, 1)) - tonumber(mvindex(c_hs, 0))), 1=1, null()) 
    | eval c_wdays=if(match(c_wday, ","), split(c_wday, ","), null()) 
    | eval c_wday_div=case(match(c_wday, "/"), replace(c_wday, "^.*/(\d+)$$", "\1"), isnotnull(c_wdays), abs(tonumber(mvindex(c_wdays, 1)) - tonumber(mvindex(c_wdays, 0))), 1=1, null()) 
    | eval i_m=case(c_d &lt; 29, 86400 * 28, c_d = 31, 86400 * 31, 1=1, null()) 
    | eval i_h=case(isnotnull(c_h_div), c_h_div * 3600, c_h = "*", null(), match(c_h, "^\d+$$"), 86400) 
    | eval i_min=case(isnotnull(c_min_div), c_min_div * 60, c_min = "*", 60, match(c_min, "^\d+$$"), 3600) 
    | eval i_wk=case(isnotnull(c_wday_div), c_wday_div * 86400, c_wday = "*", null(), match(c_wday, "^\d+$$"), 604800) 
    | eval cron_minimum_freq=case(isnotnull(i_m), i_m, isnotnull(i_wk) AND isnotnull(c_min_div), i_min, isnotnull(i_wk) AND isnull(c_min_div), i_wk, isnotnull(i_h), i_h, 1=1, min(i_min)) 
    | fields - c_d c_h c_hs c_h_div c_mday c_min c_min_div c_mins c_wday c_wdays c_wday_div pieces i_m i_min i_h i_wk 
    | fields savedsearch_name cron_minimum_freq cron_schedule eai:acl.app] 
| eval magic=cron_minimum_freq*3 
| where timesearched&gt;magic
| eval ratio=round(timesearched/cron_minimum_freq,0) . ":" . 1, timesearched=round(timesearched/60,0), cron_minimum_freq=cron_minimum_freq/60
| dedup savedsearch_name 
| table savedsearch_name, eai:acl.app, user, timesearched, cron_minimum_freq, cron_schedule, ratio 
| rename savedsearch_name AS "Saved Search Name", eai:acl.app AS "App", user AS "User", timesearched AS "Time Searched (Minutes)", cron_minimum_freq as "Minimum Frequency (Minutes)", cron_schedule AS "Cron Schedule", ratio as Ratio  | stats count as "number of scheduled searches" by Ratio | sort -Ratio | table Ratio "number of scheduled searches"</query>
          <earliest>-60m@m</earliest>
          <latest>now</latest>
          <sampleRatio>1</sampleRatio>
        </search>
        <option name="count">5</option>
        <option name="dataOverlayMode">none</option>
        <option name="drilldown">cell</option>
        <option name="percentagesRow">false</option>
        <option name="refresh.display">progressbar</option>
        <option name="rowNumbers">false</option>
        <option name="totalsRow">false</option>
        <option name="wrap">false</option>
        <drilldown>
          <set token="r1">$click.value$</set>
        </drilldown>
      </table>
      <html>
        <p>Click Ratio value above to see searches.</p>
       
      </html>
    </panel>
  </row>
  <row>
    <panel depends="$r1$">
      <html>
    <a data-unset-token="r1">Close this panel</a>
  </html>
      <table>
        <search>
          <query>index=_audit sourcetype=audittrail source=audittrail savedsearch_name!="" TERM(action=search) ( TERM(info=completed) OR ( TERM(info=granted) search_et=* "search='search")) NOT "search_id='rsa_*" 
| eval timesearched = round((search_lt-search_et),0)
| fields savedsearch_name, timesearched, user
| join savedsearch_name 
    [| rest splunk_server=$captain_name$ "/servicesNS/-/-/saved/searches/" search="is_scheduled=1" search="disabled=0" 
    | fields title, cron_schedule, eai:acl.app
    | rename title as savedsearch_name 
    | eval pieces=split(cron_schedule, " ") 
    | eval c_min=mvindex(pieces, 0), c_h=mvindex(pieces, 1), c_d=mvindex(pieces, 2), c_mday=mvindex(pieces, 3), c_wday=mvindex(pieces, 4) 
    | eval c_min_div=if(match(c_min, "/"), replace(c_min, "^.*/(\d+)$$", "\1"), null()) 
    | eval c_mins=if(match(c_min, ","), split(c_min, ","), null()) 
    | eval c_min_div=if(isnotnull(c_mins), abs(tonumber(mvindex(c_mins, 1)) - tonumber(mvindex(c_mins, 0))), c_min_div) 
    | eval c_hs=if(match(c_h, ","), split(c_h, ","), null()) 
    | eval c_h_div=case(match(c_h, "/"), replace(c_h, "^.*/(\d+)$$", "\1"), isnotnull(c_hs), abs(tonumber(mvindex(c_hs, 1)) - tonumber(mvindex(c_hs, 0))), 1=1, null()) 
    | eval c_wdays=if(match(c_wday, ","), split(c_wday, ","), null()) 
    | eval c_wday_div=case(match(c_wday, "/"), replace(c_wday, "^.*/(\d+)$$", "\1"), isnotnull(c_wdays), abs(tonumber(mvindex(c_wdays, 1)) - tonumber(mvindex(c_wdays, 0))), 1=1, null()) 
    | eval i_m=case(c_d &lt; 29, 86400 * 28, c_d = 31, 86400 * 31, 1=1, null()) 
    | eval i_h=case(isnotnull(c_h_div), c_h_div * 3600, c_h = "*", null(), match(c_h, "^\d+$$"), 86400) 
    | eval i_min=case(isnotnull(c_min_div), c_min_div * 60, c_min = "*", 60, match(c_min, "^\d+$$"), 3600) 
    | eval i_wk=case(isnotnull(c_wday_div), c_wday_div * 86400, c_wday = "*", null(), match(c_wday, "^\d+$$"), 604800) 
    | eval cron_minimum_freq=case(isnotnull(i_m), i_m, isnotnull(i_wk) AND isnotnull(c_min_div), i_min, isnotnull(i_wk) AND isnull(c_min_div), i_wk, isnotnull(i_h), i_h, 1=1, min(i_min)) 
    | fields - c_d c_h c_hs c_h_div c_mday c_min c_min_div c_mins c_wday c_wdays c_wday_div pieces i_m i_min i_h i_wk 
    | fields savedsearch_name cron_minimum_freq cron_schedule eai:acl.app] 
| eval magic=cron_minimum_freq*3 
| where timesearched&gt;magic
| eval ratio=round(timesearched/cron_minimum_freq,0) . ":" . 1, timesearched=round(timesearched/60,0), cron_minimum_freq=cron_minimum_freq/60
| dedup savedsearch_name 
| table savedsearch_name, eai:acl.app, user, timesearched, cron_minimum_freq, cron_schedule, ratio 
| rename savedsearch_name AS "Saved Search Name", eai:acl.app AS "App", user AS "User", timesearched AS "Time Searched (Minutes)", cron_minimum_freq as "Minimum Frequency (Minutes)", cron_schedule AS "Cron Schedule", ratio as Ratio | sort -Ratio | search Ratio=$r1$</query>
          <earliest>-60m@m</earliest>
          <latest>now</latest>
          <sampleRatio>1</sampleRatio>
        </search>
        <option name="count">5</option>
        <option name="dataOverlayMode">none</option>
        <option name="drilldown">none</option>
        <option name="percentagesRow">false</option>
        <option name="refresh.display">progressbar</option>
        <option name="rowNumbers">false</option>
        <option name="totalsRow">false</option>
        <option name="wrap">true</option>
      </table>
    </panel>
  </row>
  <row>
    <panel>
      <html>
        <h1>
          <b>
            <span style="color: #ED179F">Distinct searches by cron_schedule</span>  </b>
        
        </h1>

        <b>Description:</b> Groups number of scheduled searches by cron_schedule</html>
      <html>
        <b>Recommended Action:</b> 
          <p>
          <b>a.)</b> Identify high counts of searches scheduled on same cron schedule and shuffle the schedule away from those hot minutes</p>
        <p>
          <b>b.)</b> Add an allow_skew setting to offset scheduled search start times</p>
<p>SHs $SPLUNK_HOME/etc/system/local/savedsearches.conf</p>    
<p>[default]</p>
<p>allow_skew=60s</p> 
      </html>
      <table>
        <search>
          <query>| rest /servicesNS/-/-/saved/searches splunk_server=$captain_name$  | search  disabled=0 is_scheduled=1| table title  cron_schedule dispatch.earliest_time dispatch.latest_time auto_summarize  action.email realtime_schedule eai:acl.app eai:acl.owner schedule_priority auto_summarize.dispatch.earliest_time auto_summarize.dispatch.latest_time allow_skew  action.summary_index search  | append [ | rest /servicesNS/-/-/data/models splunk_server=$captain_name$| search acceleration=1 | table title acceleration.cron_schedule acceleration.earliest_time acceleration.max_time dataset.type eai:acl.app eai:acl.owner  | rename acceleration.cron_schedule as acceleration_cron_schedule acceleration.earliest_time as acceleration_et acceleration.max_time as acceleration_max_time dataset.type as dataset_type eai:acl.app as app eai:acl.owner as owner ] | rex field=cron_schedule "(?&lt;one_minute&gt;\* \* \* \* \*)"  | stats  dc(title) as count by cron_schedule | sort -count</query>
          <earliest>-60m@m</earliest>
          <latest>now</latest>
          <sampleRatio>1</sampleRatio>
        </search>
        <option name="count">5</option>
        <option name="dataOverlayMode">none</option>
        <option name="drilldown">cell</option>
        <option name="percentagesRow">false</option>
        <option name="rowNumbers">true</option>
        <option name="totalsRow">false</option>
        <option name="wrap">true</option>
        <drilldown>
          <set token="a1">$click.value$</set>
        </drilldown>
      </table>
      <html>
        <p>Click on cron_schedule to see search details.</p>
       
      </html>
    </panel>
  </row>
  <row>
    <panel depends="$a1$">
      <title>cron schedule detail</title>
      <table>
        <search>
          <query>| rest splunk_server=$captain_name$ "/servicesNS/-/-/saved/searches/" search="is_scheduled=1"
search="disabled=0"
| fields title, eai:acl.app, eai:acl.owner, cron_schedule, dispatch.earliest_time,
dispatch.latest_time, schedule_window, actions
| rename title as "Report_Name", cron_schedule as "Cron_Schedule"

| stats count(Report_Name) AS Search_Count values(Report_Name) AS Search_Names
by Cron_Schedule

| sort - Search_Count
| table   Search_Names Cron_Schedule Search_Count</query>
          <earliest>$time.earliest$</earliest>
          <latest>$time.latest$</latest>
          <sampleRatio>1</sampleRatio>
        </search>
        <option name="count">100</option>
        <option name="dataOverlayMode">none</option>
        <option name="drilldown">none</option>
        <option name="percentagesRow">false</option>
        <option name="refresh.display">progressbar</option>
        <option name="rowNumbers">false</option>
        <option name="totalsRow">false</option>
        <option name="wrap">true</option>
      </table>
    </panel>
  </row>
  <row>
    <panel depends="$a1$">
      <html>
    <a data-unset-token="a1">Close this panel</a>
  </html>
    </panel>
  </row>
  <row>
    <panel>
      
      <html>
        <h1>
          <b>
            <span style="color: #ED179F">Scheduled Search Distribution</span>  </b>
        </h1>

        <b>Description:</b> Groups scheduled searches by cron schedule time for the last 60m</html>
      <html>
        <b>Recommended Action:</b> 
          <p> Use to identify periods with very high number of scheduled searches and adjust cron schedule away from hot minutes or use allow_skew and schedule windows</p>

      </html>
      <chart>
        <search>
          <query>| rest /servicesNS/-/-/saved/searches splunk_server=$captain_name$
search="is_scheduled=1" search="disabled=0" earliest_time=-1h@m latest_time=now 
          | table title cron_schedule scheduled_times 
          | mvexpand scheduled_times 
          | rename scheduled_times as _time 
          | timechart span=1m count as "Searches Scheduled" | join splunk_server [| rest splunk_server=$captain_name$ "/services/server/status/limits/search-concurrency?cluster_wide_quota=1"
              | stats max(max_hist_scheduled_searches) as max_clusterwide_scheduler_concurrency ]</query>
          <earliest>$time.earliest$</earliest>
          <latest>$time.latest$</latest>
          <sampleRatio>1</sampleRatio>
        </search>
        <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
        <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
        <option name="charting.axisTitleX.text">minute of the hour</option>
        <option name="charting.axisTitleX.visibility">visible</option>
        <option name="charting.axisTitleY.visibility">visible</option>
        <option name="charting.axisTitleY2.visibility">visible</option>
        <option name="charting.axisX.abbreviation">none</option>
        <option name="charting.axisX.scale">linear</option>
        <option name="charting.axisY.abbreviation">none</option>
        <option name="charting.axisY.scale">linear</option>
        <option name="charting.axisY2.abbreviation">none</option>
        <option name="charting.axisY2.enabled">0</option>
        <option name="charting.axisY2.scale">inherit</option>
        <option name="charting.chart">column</option>
        <option name="charting.chart.bubbleMaximumSize">50</option>
        <option name="charting.chart.bubbleMinimumSize">10</option>
        <option name="charting.chart.bubbleSizeBy">area</option>
        <option name="charting.chart.nullValueMode">gaps</option>
        <option name="charting.chart.overlayFields">max_clusterwide_scheduler_concurrency</option>
        <option name="charting.chart.showDataLabels">none</option>
        <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
        <option name="charting.chart.stackMode">default</option>
        <option name="charting.chart.style">shiny</option>
        <option name="charting.drilldown">all</option>
        <option name="charting.layout.splitSeries">0</option>
        <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
        <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
        <option name="charting.legend.mode">standard</option>
        <option name="charting.legend.placement">right</option>
        <option name="charting.lineWidth">2</option>
        <option name="refresh.display">progressbar</option>
        <option name="trellis.enabled">0</option>
        <option name="trellis.scales.shared">1</option>
        <option name="trellis.size">medium</option>
        <drilldown>
          <set token="c1">$click.value$</set>
        </drilldown>
      </chart>
    </panel>
  </row>
  <row>
    <panel depends="$c1$">
      <title>number of searches scheduled at $c1$</title>
      <table>
        <search>
          <query>| rest /servicesNS/-/-/saved/searches splunk_server=$captain_name$
    search="is_scheduled=1" search="disabled=0" earliest_time=-1h@m latest_time=now 
| mvexpand scheduled_times 

| search scheduled_times=$c1$
| table title scheduled_times eai:acl.app eai:acl.owner | rename title as savedsearch_name eai:acl.app as app eai:acl.owner as owner | convert ctime(scheduled_times) as scheduled_times | stats values(savedsearch_name) as savedsearch_name by scheduled_times app owner</query>
          <earliest>$time.earliest$</earliest>
          <latest>$time.latest$</latest>
          <sampleRatio>1</sampleRatio>
        </search>
        <option name="count">1</option>
        <option name="dataOverlayMode">none</option>
        <option name="drilldown">none</option>
        <option name="percentagesRow">false</option>
        <option name="refresh.display">progressbar</option>
        <option name="rowNumbers">true</option>
        <option name="totalsRow">false</option>
        <option name="wrap">true</option>
      </table>
      <html>
    <a data-unset-token="c1">Close this panel</a>
  </html>
    </panel>
  </row>
  <row>
    <panel>
      <html>
        <h1>
          <b>
            <span style="color: #ED179F">Average search runtime</span>  </b>
        </h1>

        <b>Description:</b> Calculates average runtime of completed searches</html>
      <html>
        <b>Recommended Action:</b> 
          <p> Use to identify trends in increased search runtime</p>

      </html>
    </panel>
  </row>
  <row>
    <panel>
      <input type="multiselect" token="savedsearch_name" searchWhenChanged="true">
        <label>saved search name</label>
        <choice value="*">All</choice>
        <valuePrefix>"</valuePrefix>
        <delimiter> OR </delimiter>
        <fieldForLabel>savedsearch_name</fieldForLabel>
        <fieldForValue>savedsearch_name</fieldForValue>
        <search>
          <query>| rest /servicesNS/-/-/saved/searches splunk_server=$captain_name$  | search  disabled=0 is_scheduled=1 | rename title as savedsearch_name | table savedsearch_name</query>
          <earliest>-15m</earliest>
          <latest>now</latest>
        </search>
        <prefix>savedsearch_name=</prefix>
        <valueSuffix>"</valueSuffix>
      </input>
      <input type="time" token="time5" searchWhenChanged="true">
        <label></label>
        <default>
          <earliest>-60m@m</earliest>
          <latest>now</latest>
        </default>
      </input>
      <input type="dropdown" token="span1" searchWhenChanged="true">
        <label>span</label>
        <choice value="minspan=10s">auto</choice>
        <choice value="span=1m">1m</choice>
        <choice value="span=5m">5m</choice>
        <choice value="span=15m">15m</choice>
        <choice value="span=1h">1h</choice>
        <choice value="span=4h">4h</choice>
        <choice value="span=1d">1d</choice>
        <default>minspan=10s</default>
        <initialValue>minspan=10s</initialValue>
      </input>
      <chart>
        <search>
          <query>index=_audit search_group=dmc_group_search_head search_group="$group$" source=audittrail search_id=* NOT user="splunk-system-user" NOT user="n/a" NOT search_id=rt_* action=search info=completed $savedsearch_name$
| timechart $span1$ avg(total_run_time) AS avg
| eval avg=round(avg,2)</query>
          <earliest>$time5.earliest$</earliest>
          <latest>$time5.latest$</latest>
          <sampleRatio>1</sampleRatio>
        </search>
        <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
        <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
        <option name="charting.axisTitleX.visibility">visible</option>
        <option name="charting.axisTitleY.visibility">visible</option>
        <option name="charting.axisTitleY2.visibility">visible</option>
        <option name="charting.axisX.abbreviation">none</option>
        <option name="charting.axisX.scale">linear</option>
        <option name="charting.axisY.abbreviation">none</option>
        <option name="charting.axisY.scale">linear</option>
        <option name="charting.axisY2.abbreviation">none</option>
        <option name="charting.axisY2.enabled">0</option>
        <option name="charting.axisY2.scale">inherit</option>
        <option name="charting.chart">area</option>
        <option name="charting.chart.bubbleMaximumSize">50</option>
        <option name="charting.chart.bubbleMinimumSize">10</option>
        <option name="charting.chart.bubbleSizeBy">area</option>
        <option name="charting.chart.nullValueMode">gaps</option>
        <option name="charting.chart.showDataLabels">none</option>
        <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
        <option name="charting.chart.stackMode">default</option>
        <option name="charting.chart.style">shiny</option>
        <option name="charting.drilldown">none</option>
        <option name="charting.layout.splitSeries">0</option>
        <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
        <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
        <option name="charting.legend.mode">standard</option>
        <option name="charting.legend.placement">right</option>
        <option name="charting.lineWidth">2</option>
        <option name="refresh.display">progressbar</option>
        <option name="trellis.enabled">0</option>
        <option name="trellis.scales.shared">1</option>
        <option name="trellis.size">medium</option>
      </chart>
    </panel>
  </row>
  <row>
    <panel>
      <html>
        <h1>
          <b>
            <span style="color: #ED179F">Orphaned searches</span>  </b>
        
        </h1>

        <b>Description:</b> How many times Splunk queried ldap and did not find a valid user.
</html>
      <html>
        <p>
          <b>Recommended Action:</b> Resolve orphaned searches where the user no longer exists in LDAP by moving ownership of the search to a new user.</p>
          </html>
      <chart>
        <search>
          <query>index=_internal search_group=dmc_group_search_head search_group="$group$"  source=*splunkd.log*  "could not find a valid user" OR "Failed to get LDAP user" |timechart count by host</query>
          <earliest>$time.earliest$</earliest>
          <latest>$time.latest$</latest>
          <sampleRatio>1</sampleRatio>
        </search>
        <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
        <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
        <option name="charting.axisTitleX.visibility">visible</option>
        <option name="charting.axisTitleY.visibility">visible</option>
        <option name="charting.axisTitleY2.visibility">visible</option>
        <option name="charting.axisX.abbreviation">none</option>
        <option name="charting.axisX.scale">linear</option>
        <option name="charting.axisY.abbreviation">none</option>
        <option name="charting.axisY.scale">linear</option>
        <option name="charting.axisY2.abbreviation">none</option>
        <option name="charting.axisY2.enabled">0</option>
        <option name="charting.axisY2.scale">inherit</option>
        <option name="charting.chart">column</option>
        <option name="charting.chart.bubbleMaximumSize">50</option>
        <option name="charting.chart.bubbleMinimumSize">10</option>
        <option name="charting.chart.bubbleSizeBy">area</option>
        <option name="charting.chart.nullValueMode">gaps</option>
        <option name="charting.chart.showDataLabels">none</option>
        <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
        <option name="charting.chart.stackMode">stacked</option>
        <option name="charting.chart.style">shiny</option>
        <option name="charting.drilldown">none</option>
        <option name="charting.layout.splitSeries">0</option>
        <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
        <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
        <option name="charting.legend.mode">standard</option>
        <option name="charting.legend.placement">right</option>
        <option name="charting.lineWidth">2</option>
        <option name="refresh.display">progressbar</option>
        <option name="trellis.enabled">0</option>
        <option name="trellis.scales.shared">1</option>
        <option name="trellis.size">medium</option>
      </chart>
    </panel>
  </row>
  <row>
    <panel>
      <html>
        <h1>
          <b>
            <span style="color: #ED179F">Search Head idle cpu</span>  </b>
        
        </h1>

        <b>Description:</b> Shows minimum idle cpu % across all search heads
</html>
      <html>
        <p>
          <b>Recommended Action:</b> If minimum idle cpu % is very low, review Monitoring Console Resource Usage views.</p>
          </html>
      <chart>
        <search>
          <query>index=_introspection search_group=dmc_group_search_head search_group="$group$"   source=*resource_usage.log*   OR  hostwide | timechart span=30s  min(data.cpu_idle_pct)</query>
          <earliest>$time.earliest$</earliest>
          <latest>$time.latest$</latest>
          <sampleRatio>1</sampleRatio>
        </search>
        <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
        <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
        <option name="charting.axisTitleX.visibility">visible</option>
        <option name="charting.axisTitleY.text">min data.idle_cpu%</option>
        <option name="charting.axisTitleY.visibility">visible</option>
        <option name="charting.axisTitleY2.visibility">visible</option>
        <option name="charting.axisX.abbreviation">none</option>
        <option name="charting.axisX.scale">linear</option>
        <option name="charting.axisY.abbreviation">none</option>
        <option name="charting.axisY.scale">linear</option>
        <option name="charting.axisY2.abbreviation">none</option>
        <option name="charting.axisY2.enabled">0</option>
        <option name="charting.axisY2.scale">inherit</option>
        <option name="charting.chart">line</option>
        <option name="charting.chart.bubbleMaximumSize">50</option>
        <option name="charting.chart.bubbleMinimumSize">10</option>
        <option name="charting.chart.bubbleSizeBy">area</option>
        <option name="charting.chart.nullValueMode">gaps</option>
        <option name="charting.chart.showDataLabels">none</option>
        <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
        <option name="charting.chart.stackMode">default</option>
        <option name="charting.chart.style">shiny</option>
        <option name="charting.drilldown">none</option>
        <option name="charting.layout.splitSeries">0</option>
        <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
        <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
        <option name="charting.legend.mode">standard</option>
        <option name="charting.legend.placement">right</option>
        <option name="charting.lineWidth">2</option>
        <option name="refresh.display">progressbar</option>
        <option name="trellis.enabled">0</option>
        <option name="trellis.scales.shared">1</option>
        <option name="trellis.size">medium</option>
      </chart>
    </panel>
    <panel>
      <html>
        <h1>
          <b>
            <span style="color: #ED179F">Search Head disk latency</span>  </b>
        
        </h1>

        <b>Description:</b> The average time (in milliseconds) for I/O requests issued to the device to be served. This includes the time spent by the requests in queue and the time spent servicing them.
</html>
      <html>
        <p>
          <b>Recommended Action:</b> Use to review search head disk latency.</p>
          </html>
      <chart>
        <title></title>
        <search>
          <query>index=_introspection search_group=dmc_group_search_head search_group="$group$"  source=*resource_usage.log* component=IOstats data.avg_total_ms&gt;0 "data.mount_point"=*| timechart minspan=10s limit=60 max(data.avg_total_ms) by data.mount_point</query>
          <earliest>$time.earliest$</earliest>
          <latest>$time.latest$</latest>
          <sampleRatio>1</sampleRatio>
        </search>
        <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
        <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
        <option name="charting.axisTitleX.visibility">visible</option>
        <option name="charting.axisTitleY.text">max data.avg_total_ms</option>
        <option name="charting.axisTitleY.visibility">visible</option>
        <option name="charting.axisTitleY2.visibility">visible</option>
        <option name="charting.axisX.abbreviation">none</option>
        <option name="charting.axisX.scale">linear</option>
        <option name="charting.axisY.abbreviation">none</option>
        <option name="charting.axisY.scale">linear</option>
        <option name="charting.axisY2.abbreviation">none</option>
        <option name="charting.axisY2.enabled">0</option>
        <option name="charting.axisY2.scale">inherit</option>
        <option name="charting.chart">area</option>
        <option name="charting.chart.bubbleMaximumSize">50</option>
        <option name="charting.chart.bubbleMinimumSize">10</option>
        <option name="charting.chart.bubbleSizeBy">area</option>
        <option name="charting.chart.nullValueMode">gaps</option>
        <option name="charting.chart.showDataLabels">none</option>
        <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
        <option name="charting.chart.stackMode">default</option>
        <option name="charting.chart.style">shiny</option>
        <option name="charting.drilldown">none</option>
        <option name="charting.layout.splitSeries">0</option>
        <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
        <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
        <option name="charting.legend.mode">standard</option>
        <option name="charting.legend.placement">right</option>
        <option name="charting.lineWidth">2</option>
        <option name="refresh.display">progressbar</option>
        <option name="trellis.enabled">0</option>
        <option name="trellis.scales.shared">1</option>
        <option name="trellis.size">medium</option>
      </chart>
    </panel>
  </row>
  <row>
    <panel>
      <input type="dropdown" searchWhenChanged="true" token="dmc_group">
        <label>Select Index Cluster</label>
        <showClearButton>false</showClearButton>
        <selectFirstChoice>false</selectFirstChoice>
        <search>
          <query>
          | `dmc_get_groups_containing_role(dmc_group_indexer)`
          | search search_group!="dmc_group_*"
        </query>
        </search>
        <fieldForLabel>label</fieldForLabel>
        <fieldForValue>search_group</fieldForValue>
        <choice value="dmc_group_indexer">All Indexers</choice>
      </input>
      <input type="time" searchWhenChanged="true" token="time2">
        <label>Time Range:</label>
        <default>
          <earliest>-60m@m</earliest>
          <latest>now</latest>
        </default>
      </input>
    </panel>
  </row>
  <row>
    <panel>
      <html>
        <h1>
          <b>
            <span style="color: #ED179F">Indexer idle cpu</span>  </b>
        
        </h1>

        <b>Description:</b> Shows minimum idle cpu % across all indexers
</html>
      <html>
        <p>
          <b>Recommended Action:</b> If minimum idle cpu % is very low, review Monitoring Console Resource Usage views.</p>
          </html>
      <chart>
        <search>
          <query>index=_introspection search_group="dmc_group_indexer" search_group="$dmc_group$"  source=*resource_usage.log*   hostwide | timechart span=30s  min(data.cpu_idle_pct)</query>
          <earliest>$time2.earliest$</earliest>
          <latest>$time2.latest$</latest>
          <sampleRatio>1</sampleRatio>
        </search>
        <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
        <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
        <option name="charting.axisTitleX.visibility">visible</option>
        <option name="charting.axisTitleY.text">min data.idle_cpu%</option>
        <option name="charting.axisTitleY.visibility">visible</option>
        <option name="charting.axisTitleY2.visibility">visible</option>
        <option name="charting.axisX.abbreviation">none</option>
        <option name="charting.axisX.scale">linear</option>
        <option name="charting.axisY.abbreviation">none</option>
        <option name="charting.axisY.scale">linear</option>
        <option name="charting.axisY2.abbreviation">none</option>
        <option name="charting.axisY2.enabled">0</option>
        <option name="charting.axisY2.scale">inherit</option>
        <option name="charting.chart">line</option>
        <option name="charting.chart.bubbleMaximumSize">50</option>
        <option name="charting.chart.bubbleMinimumSize">10</option>
        <option name="charting.chart.bubbleSizeBy">area</option>
        <option name="charting.chart.nullValueMode">gaps</option>
        <option name="charting.chart.showDataLabels">none</option>
        <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
        <option name="charting.chart.stackMode">default</option>
        <option name="charting.chart.style">shiny</option>
        <option name="charting.drilldown">none</option>
        <option name="charting.layout.splitSeries">0</option>
        <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
        <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
        <option name="charting.legend.mode">standard</option>
        <option name="charting.legend.placement">right</option>
        <option name="charting.lineWidth">2</option>
        <option name="refresh.display">progressbar</option>
        <option name="trellis.enabled">0</option>
        <option name="trellis.scales.shared">1</option>
        <option name="trellis.size">medium</option>
      </chart>
    </panel>
    <panel>
      <html>
        <h1>
          <b>
            <span style="color: #ED179F">Indexer disk latency</span>  </b>
        
        </h1>

        <b>Description:</b> The average time (in milliseconds) for I/O requests issued to the device to be served. This includes the time spent by the requests in queue and the time spent servicing them.
</html>
      <html>
        <p>
          <b>Recommended Action:</b> Use to review Indexer disk latency.(ideal latency ~5-10ms for mountpoint where indexed data resides)</p>
          </html>
      <chart>
        <search>
          <query>index=_introspection search_group="dmc_group_indexer" search_group="$dmc_group$" source=*resource_usage.log* component=IOstats data.avg_total_ms&gt;0 "data.mount_point"=*| timechart minspan=10s limit=60 max(data.avg_total_ms) by data.mount_point | eval ideal_latency=10</query>
          <earliest>$time2.earliest$</earliest>
          <latest>$time2.latest$</latest>
          <sampleRatio>1</sampleRatio>
        </search>
        <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
        <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
        <option name="charting.axisTitleX.visibility">visible</option>
        <option name="charting.axisTitleY.text">max data.avg_total_ms</option>
        <option name="charting.axisTitleY.visibility">visible</option>
        <option name="charting.axisTitleY2.visibility">visible</option>
        <option name="charting.axisX.abbreviation">none</option>
        <option name="charting.axisX.scale">linear</option>
        <option name="charting.axisY.abbreviation">none</option>
        <option name="charting.axisY.scale">linear</option>
        <option name="charting.axisY2.abbreviation">none</option>
        <option name="charting.axisY2.enabled">0</option>
        <option name="charting.axisY2.scale">inherit</option>
        <option name="charting.chart">area</option>
        <option name="charting.chart.bubbleMaximumSize">50</option>
        <option name="charting.chart.bubbleMinimumSize">10</option>
        <option name="charting.chart.bubbleSizeBy">area</option>
        <option name="charting.chart.nullValueMode">connect</option>
        <option name="charting.chart.overlayFields">ideal_latency</option>
        <option name="charting.chart.showDataLabels">none</option>
        <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
        <option name="charting.chart.stackMode">default</option>
        <option name="charting.chart.style">shiny</option>
        <option name="charting.drilldown">none</option>
        <option name="charting.layout.splitSeries">0</option>
        <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
        <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
        <option name="charting.legend.mode">standard</option>
        <option name="charting.legend.placement">right</option>
        <option name="charting.lineWidth">2</option>
        <option name="refresh.display">progressbar</option>
        <option name="trellis.enabled">0</option>
        <option name="trellis.scales.shared">1</option>
        <option name="trellis.size">medium</option>
      </chart>
    </panel>
  </row>
  <row>
    <panel>
      <html>
        <h1>
          <b>
            <span style="color: #ED179F">S2 Cache Hits/Misses</span>  </b>
        
        </h1>

        <b>Description:</b> When a search needs a bucket and it's already in cache, that's a hit. If the bucket needs to be downloaded, that's a miss. Applies only to SmartStore enabled indexes</html>
      <html>
        <b>Recommended Action:</b> 
          <p> High number of misses could be due to long look back searches or insufficient cache size on indexers </p>

      </html>
      <chart>
        <search>
          <query>index=_internal search_group="dmc_group_indexer" search_group="$dmc_group$"   group=cachemgr_bucket source=*metrics.log | timechart count(cache_hit) as Hits count(cache_miss) as Misses</query>
          <earliest>$time2.earliest$</earliest>
          <latest>$time2.latest$</latest>
          <sampleRatio>1</sampleRatio>
        </search>
        <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
        <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
        <option name="charting.axisTitleX.visibility">visible</option>
        <option name="charting.axisTitleY.visibility">visible</option>
        <option name="charting.axisTitleY2.visibility">visible</option>
        <option name="charting.axisX.abbreviation">none</option>
        <option name="charting.axisX.scale">linear</option>
        <option name="charting.axisY.abbreviation">none</option>
        <option name="charting.axisY.scale">linear</option>
        <option name="charting.axisY2.abbreviation">none</option>
        <option name="charting.axisY2.enabled">0</option>
        <option name="charting.axisY2.scale">inherit</option>
        <option name="charting.chart">column</option>
        <option name="charting.chart.bubbleMaximumSize">50</option>
        <option name="charting.chart.bubbleMinimumSize">10</option>
        <option name="charting.chart.bubbleSizeBy">area</option>
        <option name="charting.chart.nullValueMode">gaps</option>
        <option name="charting.chart.showDataLabels">none</option>
        <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
        <option name="charting.chart.stackMode">default</option>
        <option name="charting.chart.style">shiny</option>
        <option name="charting.drilldown">none</option>
        <option name="charting.layout.splitSeries">0</option>
        <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
        <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
        <option name="charting.legend.mode">standard</option>
        <option name="charting.legend.placement">right</option>
        <option name="charting.lineWidth">2</option>
        <option name="refresh.display">progressbar</option>
        <option name="trellis.enabled">0</option>
        <option name="trellis.scales.shared">1</option>
        <option name="trellis.size">medium</option>
      </chart>
    </panel>
    <panel>
      <html>
        <h1>
          <b>
            <span style="color: #ED179F">S2 Cache Thrash by Index</span>  </b>
        
        </h1>

        <b>Description:</b> This is the percentage of bucket downloads that are repeats. This happens when a bucket is downloaded for a search, evicted based on policy, and then needed by a search again. "Excessively Repeated Downloads" are buckets that have been downloaded more than 10 times.</html>
      <html>
        <b>Recommended Action:</b> 
          <p> High number of misses could be due to long look back searches or insufficient cache size on indexers </p>

      </html>
      <chart>
        <title></title>
        <search>
          <query>`dmc_set_index_internal` search_group="dmc_group_indexer" search_group="$dmc_group$"  source=*splunkd.log CacheManager AND TERM(action=download) AND TERM(status=succeeded) AND download_set="*journal*"
              | rex field=cache_id ".*\|(?&lt;customer_index&gt;.*)~.*~.*\|"
              | eval identifier=(cache_id + host)
              | stats count by identifier, customer_index
              | stats count(eval(count&gt;1)) as duplicate_downloads, sum(count) as all_downloads count(eval(count&gt;=10)) as excessive_duplicate_downloads by customer_index
              | eval duplicate_percent=if(all_downloads=0, 0, round((duplicate_downloads/all_downloads)*100, 2))
              | sort  - duplicate_percent
              | fields customer_index, duplicate_percent  all_downloads duplicate_downloads excessive_duplicate_downloads 
              | rename customer_index as Index, duplicate_percent as "Repeat Download Percent",  all_downloads as "All Downloads", duplicate_downloads as "Repeated Downloads", excessive_duplicate_downloads as "Excessively Repeated Downloads"</query>
          <earliest>$time2.earliest$</earliest>
          <latest>$time2.latest$</latest>
          <sampleRatio>1</sampleRatio>
        </search>
        <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
        <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
        <option name="charting.axisTitleX.visibility">visible</option>
        <option name="charting.axisTitleY.visibility">visible</option>
        <option name="charting.axisTitleY2.visibility">visible</option>
        <option name="charting.axisX.abbreviation">none</option>
        <option name="charting.axisX.scale">linear</option>
        <option name="charting.axisY.abbreviation">none</option>
        <option name="charting.axisY.scale">linear</option>
        <option name="charting.axisY2.abbreviation">none</option>
        <option name="charting.axisY2.enabled">0</option>
        <option name="charting.axisY2.scale">inherit</option>
        <option name="charting.chart">column</option>
        <option name="charting.chart.bubbleMaximumSize">50</option>
        <option name="charting.chart.bubbleMinimumSize">10</option>
        <option name="charting.chart.bubbleSizeBy">area</option>
        <option name="charting.chart.nullValueMode">gaps</option>
        <option name="charting.chart.showDataLabels">none</option>
        <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
        <option name="charting.chart.stackMode">default</option>
        <option name="charting.chart.style">shiny</option>
        <option name="charting.drilldown">none</option>
        <option name="charting.layout.splitSeries">0</option>
        <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
        <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
        <option name="charting.legend.mode">standard</option>
        <option name="charting.legend.placement">right</option>
        <option name="charting.lineWidth">2</option>
        <option name="refresh.display">progressbar</option>
        <option name="trellis.enabled">0</option>
        <option name="trellis.scales.shared">1</option>
        <option name="trellis.size">medium</option>
      </chart>
    </panel>
  </row>
  <row>
    <panel>
      <input type="time" token="time3" searchWhenChanged="true">
        <label></label>
        <default>
          <earliest>-24h@h</earliest>
          <latest>now</latest>
        </default>
      </input>
      <html>
        <h1>
          <b>
            <span style="color: #ED179F">Ingested Data Distribution</span>  </b>
        
        </h1>

        <b>Description:</b> Shows ingested data distribution across indexers</html>
      <html>
        <b>Recommended Action:</b> 
          <p> Use to identify large imbalance of data across indexers. Use Monitoring Console view Indexing Performance: Instance to further diagnose </p>

      </html>
      <table>
        <search>
          <query>index=_internal search_group="dmc_group_indexer" search_group="$dmc_group$"   source=*metrics.log* group=tcpin_connections | eval sourceHost=if(isnull(hostname),sourceHost,hostname)
| stats sum(kb) AS KB dc(sourceHost) AS "forwarder count" min(_time) AS mintime max(_time) AS maxtime by host
| convert ctime(mintime)
| convert ctime(maxtime)
| eval GB = round(KB / 1024 / 1024 ,2)
| table host "forwarder count" mintime maxtime KB GB | sort -GB</query>
          <earliest>$time3.earliest$</earliest>
          <latest>$time3.latest$</latest>
          <sampleRatio>1</sampleRatio>
        </search>
        <option name="count">100</option>
        <option name="dataOverlayMode">none</option>
        <option name="drilldown">cell</option>
        <option name="percentagesRow">false</option>
        <option name="rowNumbers">true</option>
        <option name="totalsRow">false</option>
        <option name="wrap">true</option>
        <drilldown>
          <set token="i1">$click.value$</set>
        </drilldown>
      </table>
      <html>
        <p>Click on indexer for thruput details</p>
       
      </html>
    </panel>
  </row>
  <row>
    <panel depends="$i1$">
      <title>per host thruput for $i1$</title>
      <chart>
        <search>
          <query>index=_internal host=$i1$ source="*metrics.log" sourcetype=splunkd group=per_Host_thruput
| eval ingest_pipe = if(isnotnull(ingest_pipe), ingest_pipe, "none")
| search ingest_pipe=*
| `dmc_timechart_for_metrics_log` per_second(kb) by series useother=false limit=15</query>
          <earliest>$time2.earliest$</earliest>
          <latest>$time2.latest$</latest>
          <sampleRatio>1</sampleRatio>
        </search>
        <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
        <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
        <option name="charting.axisTitleX.visibility">visible</option>
        <option name="charting.axisTitleY.visibility">visible</option>
        <option name="charting.axisTitleY2.visibility">visible</option>
        <option name="charting.axisX.abbreviation">none</option>
        <option name="charting.axisX.scale">linear</option>
        <option name="charting.axisY.abbreviation">none</option>
        <option name="charting.axisY.scale">linear</option>
        <option name="charting.axisY2.abbreviation">none</option>
        <option name="charting.axisY2.enabled">0</option>
        <option name="charting.axisY2.scale">inherit</option>
        <option name="charting.chart">column</option>
        <option name="charting.chart.bubbleMaximumSize">50</option>
        <option name="charting.chart.bubbleMinimumSize">10</option>
        <option name="charting.chart.bubbleSizeBy">area</option>
        <option name="charting.chart.nullValueMode">gaps</option>
        <option name="charting.chart.showDataLabels">none</option>
        <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
        <option name="charting.chart.stackMode">stacked</option>
        <option name="charting.chart.style">shiny</option>
        <option name="charting.drilldown">all</option>
        <option name="charting.layout.splitSeries">0</option>
        <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
        <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
        <option name="charting.legend.mode">standard</option>
        <option name="charting.legend.placement">right</option>
        <option name="charting.lineWidth">2</option>
        <option name="refresh.display">progressbar</option>
        <option name="trellis.enabled">0</option>
        <option name="trellis.scales.shared">1</option>
        <option name="trellis.size">medium</option>
        <drilldown>
          <set token="i1">$click.value$</set>
        </drilldown>
      </chart>
    </panel>
  </row>
  <row>
    <panel depends="$i1$">
      <html>
    <a data-unset-token="i1">Close this panel</a>
  </html>
    </panel>
  </row>
  <row>
    <panel>
      <html>
        <h1>
          <b>
            <span style="color: #ED179F">Bucket distribution across indexers</span>  </b>
        
        </h1>

        <b>Description:</b> Shows bucket distribution across indexers</html>
      <html>
        <b>Recommended Action:</b> 
          <p> Use to identify large imbalance of buckets and determine if a primary rebalance or data rebalance should be performed</p>

      </html>
      <table>
        <search>
          <query>| rest splunk_server_group=dmc_group_cluster_master splunk_server_group=$dmc_group$ /services/cluster/master/peers | fields label, is_searchable, status, site, bucket_count,primary_count, host_port_pair, last_heartbeat, replication_port, base_generation_id, title, bucket_count_by_index.*
            | eval is_searchable = if(is_searchable == 1 or is_searchable == "1", "Yes", "No")
            | `dmc_time_format(last_heartbeat)`
            | sort - last_heartbeat
            | search label="***"
            | search is_searchable="*"
            | search status="*"
            | search site="*"
            | fields label, is_searchable, status, site, bucket_count,primary_count
            | rename label as Peer, is_searchable as "Fully Searchable", status as Status, site as Site, bucket_count as Buckets, primary_count as Primaries</query>
          <earliest>-24h@h</earliest>
          <latest>now</latest>
          <sampleRatio>1</sampleRatio>
        </search>
        <option name="count">5</option>
        <option name="dataOverlayMode">none</option>
        <option name="drilldown">none</option>
        <option name="percentagesRow">false</option>
        <option name="rowNumbers">true</option>
        <option name="totalsRow">true</option>
        <option name="wrap">true</option>
      </table>
    </panel>
  </row>
  <row>
    <panel>
      <input type="multiselect" token="index" searchWhenChanged="true">
        <label>select index</label>
        <valuePrefix>index=</valuePrefix>
        <delimiter> OR </delimiter>
        <fieldForLabel>index</fieldForLabel>
        <fieldForValue>index</fieldForValue>
        <search>
          <query>| tstats count WHERE index=* OR index=_* BY index _time | dedup index | fields index</query>
          <earliest>-60m@m</earliest>
          <latest>now</latest>
        </search>
        <choice value="*">All non-internal</choice>
        <choice value="_*">All internal</choice>
      </input>
      <input type="time" token="time4" searchWhenChanged="true">
        <label></label>
        <default>
          <earliest>-4h@m</earliest>
          <latest>now</latest>
        </default>
      </input>
      <html>
        <h1>
          <b>
            <span style="color: #ED179F">Event count by index</span>  </b>
        
        </h1>

        <b>Description:</b> Timechart of event count by index</html>
      <html>
        <b>Recommended Action:</b> 
          <p> Use to identify trends in increased data ingestion</p>

      </html>
      <chart>
        <search>
          <query>| tstats count WHERE ($index$) BY index _time span=5m prestats=t
| timechart span=5m count by index</query>
          <earliest>$time4.earliest$</earliest>
          <latest>$time4.latest$</latest>
          <sampleRatio>1</sampleRatio>
        </search>
        <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
        <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
        <option name="charting.axisTitleX.visibility">visible</option>
        <option name="charting.axisTitleY.visibility">visible</option>
        <option name="charting.axisTitleY2.visibility">visible</option>
        <option name="charting.axisX.abbreviation">none</option>
        <option name="charting.axisX.scale">linear</option>
        <option name="charting.axisY.abbreviation">none</option>
        <option name="charting.axisY.scale">linear</option>
        <option name="charting.axisY2.abbreviation">none</option>
        <option name="charting.axisY2.enabled">0</option>
        <option name="charting.axisY2.scale">inherit</option>
        <option name="charting.chart">line</option>
        <option name="charting.chart.bubbleMaximumSize">50</option>
        <option name="charting.chart.bubbleMinimumSize">10</option>
        <option name="charting.chart.bubbleSizeBy">area</option>
        <option name="charting.chart.nullValueMode">gaps</option>
        <option name="charting.chart.showDataLabels">none</option>
        <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
        <option name="charting.chart.stackMode">stacked</option>
        <option name="charting.chart.style">shiny</option>
        <option name="charting.drilldown">none</option>
        <option name="charting.layout.splitSeries">0</option>
        <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
        <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
        <option name="charting.legend.mode">standard</option>
        <option name="charting.legend.placement">right</option>
        <option name="charting.lineWidth">2</option>
        <option name="refresh.display">progressbar</option>
        <option name="trellis.enabled">0</option>
        <option name="trellis.scales.shared">1</option>
        <option name="trellis.size">medium</option>
      </chart>
    </panel>
  </row>
  <row>
    <panel>
      <title>longest running searches</title>
      <input type="time" token="time6" searchWhenChanged="true">
        <label></label>
        <default>
          <earliest>-60m@m</earliest>
          <latest>now</latest>
        </default>
      </input>
      <html>
        <h1>
          <b>
            <span style="color: #ED179F">Long Running Searches</span>  </b>
        
        </h1>

        <b>Description:</b> Long running searches on the indexers</html>
      <html>
        <b>Recommended Action:</b> 
          <p> Use to target long running searches for optimization</p>

      </html>
      <table>
        <search>
          <query>`dmc_audit_get_searches_for_groups($dmc_group$)`
      | stats min(_time) as _time, values(user) as user, max(total_run_time) as total_run_time, first(search) as search, first(search_type) as search_type, first(apiStartTime) as apiStartTime, first(apiEndTime) as apiEndTime by search_id, host
      | where isnotnull(search) AND true() | search user="*" search="*"
            | eval earliest = case(like(apiStartTime, "%ZERO_TIME%") AND like(apiEndTime, "%ZERO_TIME%"), "all time", like(apiStartTime, "%ZERO_TIME%"), "-", 1 == 1, apiStartTime )
            | eval latest = case(like(apiStartTime, "%ZERO_TIME%") AND like(apiEndTime, "%ZERO_TIME%"), "all time", like(apiEndTime, "%ZERO_TIME%"), "-", 1 == 1, apiEndTime ) 
            | `dmc_time_format(_time)`
            | stats max(total_run_time) as total_run_time by search, _time, earliest, latest, search_type, user, host, search_id
            | sort - total_run_time 
            | eval total_run_time = if(isnotnull(total_run_time), total_run_time, "-")
            | fields search, total_run_time, _time, earliest, latest, search_type, user, host, search_id
            | rename search as "Report Name/Search String", total_run_time as "Search Runtime", _time as "Search Start", earliest as "Earliest Time", latest as "Latest Time", search_type as Type, user as "User", host as "Host", search_id as SID
            | fieldformat "Search Runtime" = `dmc_convert_runtime('Search Runtime')`</query>
          <earliest>$time6.earliest$</earliest>
          <latest>$time6.latest$</latest>
          <sampleRatio>1</sampleRatio>
        </search>
        <option name="count">5</option>
        <option name="dataOverlayMode">none</option>
        <option name="drilldown">none</option>
        <option name="percentagesRow">false</option>
        <option name="refresh.display">progressbar</option>
        <option name="rowNumbers">false</option>
        <option name="totalsRow">false</option>
        <option name="wrap">true</option>
      </table>
    </panel>
  </row>
  <row>
    <panel>
      <html>
                 <style>.btn-primary { margin: 5px 10px 5px 0; }</style>
                 <a target="_blank" href="skipped_deferred_search_analysis" class="btn btn-primary">continue investigation by looking at SHC skipped and deferred searches </a>
             </html>
    </panel>
  </row>
</form>
